number = 2 to power 53
bigint
string = ""
boolean = true/false
null = standalone value
undefined = value not assigned

object

typeof ''Hello" string
typeof 12    number
typeof null   object
typeof undefined    undefined

// for conversing data types
Number( ); // converted to num
String( ); // converted to str
Boolean( ); // to boolean

when converting to number
"33ab" => NaN ( Not a Number )
null =>  0 (zero)
undefined =>  NaN (Not a Number)
true => 1
false => 1
string => NaN

when we check its data type all are shown number

when converting to boolean
1 => true
"hello" => true
"" => false      ( empty string )

"1" + 2 + 2 => 122
1 + 2 + "2" => 32
1 + "2" + 2  => 122

+true => 1
+""  => 0

num1 = num2 = num3 = 4


prefix && postfix
let a = 10;
a++    //  10
a         //  11
++a    //  12
a     //  12

let b = 10;
++a    //  11
a   //  11
a++ // 11
a   //  12

type of Data Types
primitive => string, number, boolean, null, undefined, Symbol, bigInt

Reference (Non primitive) =>
Array, Objects, Functions

Ex:  const id = Symbol('123')
   const anotherId = Symbol('123')

console.log(id === anotherId);  //false

Symbol is not same also when you pass same value

const num = 342728220278766727872678n;
// this is big int

typeof
function    // function
object      // object
array     // object
Symbol  // symbol
42n  // when 'n' add in last bigint


-----------------------------------------------------------------

null > 0   // false
null == 0  // false
null >= 0  // true

null convert to 0 
but, == work differenlty in compare to > , < , >= , <=

=> null means empty not 0

Reason 
In JavaScript, when you compare null and 0 using null == 0, it results in false. To understand why, let's break it down in an easy way:
1. Data Types: null and 0 are two different data types in JavaScript. null represents the absence of any value or object, while 0 is a number.
2. Type Coercion: JavaScript attempts to compare them, but it does something called "type coercion" in the process. Type coercion means it tries to convert one or both values to a common type before comparing them.
3. The Comparison: In this case, JavaScript tries to make the values compatible for comparison. It converts null to a number, which results in 0.
4. Comparison Result: After type coercion, you are essentially comparing 0 with 0, and when you compare two equal values, the result is true. However, in this specific case, JavaScript designers decided to make null == 0 evaluate to false for clarity and to avoid unexpected behaviors. So, even though 0 and 0 are equal, the comparison null == 0 gives false.
In JavaScript, it's usually better to use the === (strict equality) operator for comparisons because it doesn't perform type coercion. So, null === 0 would result in false, indicating that these two values are not of the same type and not equal.


undefined == 0    //false
undefined > 0     //false
undefined < 0     //false
undefined >= 0    //false
undefined <= 0   //false

--------------------------------------------------------------

Stack (Primitive Type)
Heap (Non Primitive Type)

Stack gives copy of memory
Heap gives reference of memory

// all these value and variable save to stack memory

let num = 2;
let num = 4;
let str = "Satyam"   

// value stored in heap and variable stroed in stack

let user = {
    name : "satyam",
    upi: "satyam@paytm",
}

// user get reference of value from heap memory

--------------------------------------------------------------

const str = "Satyam"   // string

const str = new String("Satyam")  //object

str.toUpperCase();
str.charAt(2);
str.indexOf('t');

and many more methods of strings


